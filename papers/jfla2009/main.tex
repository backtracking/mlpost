\documentclass[twoside]{article}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{actes,alltt,url,graphicx}
\usepackage[french]{babel}

%; whizzy -pdf .

% macros
\newcommand{\ocaml}{OCaml}
\newcommand{\camllight}{Caml Light}
\newcommand{\mlpost}{\textsc{Mlpost}}
\newcommand{\metapost}{\textsc{MetaPost}}
\newcommand{\fmpost}{\textit{functional} \metapost}
\newcommand{\metafont}{\textsc{Metafont}}
\newcommand{\tikz}{\textsc{Tikz}}
\newcommand{\pstricks}{\textsc{Pstricks}}
\newcommand{\dia}{\textsc{Dia}}
\newcommand{\xfig}{\textsc{Xfig}}
\newcommand{\postscript}{PostScript}
\newcommand{\mlpictex}{mlP\hspace{-0.2em}\raisebox{-0.2em}{i}\hspace{-0.1em}c\hspace{-0.1em}\TeX}

\title{Faire bonne figure avec \mlpost}

\author{R. Bardou$^1$
        \& J. Kanig$^1$
        \& J.-C. Filliâtre$^1$
        \& S. Lescuyer$^1$}

\titlehead{Faire bonne figure avec \mlpost}%  a droite (page impaire)

\authorhead{Bardou \& Kanig \& Filliâtre \& Lescuyer}% a gauche (page paire)

\affiliation{\begin{tabular}{rr} 
\\ 1:  ProVal / INRIA Saclay -- Île-de-France
\\     91893 Orsay Cedex, France
\\     LRI / CNRS -- Université Paris Sud
\\     91405 Orsay Cedex, France
\\     {\tt \{bardou,kanig,filliatr,lescuyer\}@lri.fr} 
\end{tabular}}

\begin{document}
\setcounter{page}{1}
\maketitle

\begin{abstract}
  
\end{abstract}

\section{Introduction}

% justifier la nécessité d'un bon mariage avec LaTeX

Il existe plusieurs familles d'outils pour réaliser des figures à
intégrer dans un document \LaTeX~:
\begin{itemize}
\item des interfaces graphiques disposant d'une sortie \LaTeX, telles
  que \dia~\cite{dia} ou \xfig~\cite{xfig} ;
\item des bibliothèques \LaTeX, telles que \pstricks~\cite{pstricks}
  ou encore \tikz~\cite{tikz} ; 
\item des outils externes en ligne de commande, tel 
  \metapost~\cite{metapost}.
\end{itemize}

Chaque famille a ses avantages et ses inconvénients. Les interfaces
graphiques sont les plus accessibles, notamment pour un placement
rapide et intuitif des différents éléments de la figure, mais
l'intégration de texte mis en forme par \LaTeX\ est délicate. Dans le
cas de \xfig\ et de \dia, la taille des éléments \LaTeX\ n'est pas
connue lors de l'édition de la figure ; en outre, 
dans le cas de \dia, l'intégration de \LaTeX\ dans une figure
nécessite de l'exporter sous forme de macros \tikz\ et d'éditer le résultat.

Les bibliothèques \LaTeX\ telles que \pstricks\ ou \tikz\ offrent
l'intégration la plus naturelle avec \LaTeX. En particulier, elles
permettent de combiner arbitrairement éléments graphiques et textes \LaTeX.
% TODO un exemple en ligne ici ?
En revanche, elles demandent d'apprendre un certain nombre de macros
et de notations et souffrent surtout des défauts inhérents à \LaTeX~:
\begin{itemize}
\item des erreurs détectées uniquement à
  l'interprétation, peu claires et parfois mal localisées ;
\item un langage \emph{de programmation} peu commode (syntaxe obscure,
  absence de typage, code difficile à structurer).
\end{itemize}
Ces inconvénients sont notamment un frein au développement de
bibliothèques de haut niveau au dessus de ces langages ainsi qu'à la
réutilisation de figures.

\metapost\ se présente comme une alternative à ces bibliothèques
\LaTeX, en proposant un langage de programmation à part entière
spécialisé dans la construction de figures contenant des éléments
\LaTeX. Il permet notamment de manipuler symboliquement la taille et
la position de ces éléments et de les relier de manière implicite par
des équations. En revanche, le langage de \metapost\ s'inspire de
celui de \metafont~\cite{metafont} et présente, à l'exception de la
syntaxe, les défauts soulevés ci-dessus.
% TODO  exemple metapost ?
% citer asymptote ?

Une alternative séduisante aux solutions précédentes consiste à
utiliser un langage de programmation existant. Ainsi l'utilisateur n'a
pas à apprendre un langage spécialisé et il bénéficie d'autre part de
tous les avantages d'un langage de programmation moderne : erreurs
détectées à la compilation, types de données complexes, structuration, etc.
Toute la difficulté réside alors dans la manipulation des éléments
\LaTeX, notamment la prise en compte de leur taille dans l'élaboration
de la figure. Si on considère la famille des langages fonctionnels, on
peut citer au moins deux exemples de telle intégration :
\begin{itemize}
\item \mlpictex~\cite{mlpictex} est\footnote{À notre connaissance,
    \mlpictex\ n'est plus distribué.} un ensemble de macros \LaTeX\ permettant
  d'inclure du code \camllight\ arbitraire dans un document \LaTeX.
  Ce code s'appuie sur une bibliothèque de dessin \postscript\ et peut
  faire référence à des éléments \LaTeX, ainsi qu'à leur taille.

\item \fmpost~\cite{fmpost} est une bibliothèque Haskell produisant du
  code \metapost. C'est une approche légère qui réutilise les
  capacités graphiques de \metapost\ et ne fait que changer le langage
  de programmation.
\end{itemize}
C'est cette dernière approche qu'adopte \mlpost.

\medskip

Cet article est organisé de la manière suivante. 
La section~\ref{exemples} ...
La section~\ref{archi} ...
Enfin, la section~\ref{conclusion} ...

%%% CONS

% pas de baseline

% pas de mélange entre LaTeX et les graphiques


\section{Principes et exemples}\label{exemples}

choix de la persistance

placement relatif plutôt qu'absolu

% automate -- RB
\begin{minipage}{0.2\linewidth}
  \includegraphics{automate.mps}
\end{minipage}
\begin{minipage}{0.2\linewidth}
\small\begin{ocaml}
let automate =
  let states = Box.vbox ~padding:(cm 0.8) [
    Box.hbox ~padding:(cm 1.4) [ 
      state ~name:"alpha" "$\\alpha$"; state ~name:"beta" "$\\beta$" ];
    final (state ~name:"gamma" "$\\gamma$"); ]
  in
  [Box.draw states;
   transition states "a" `Lowleft "alpha" "gamma";
   transition states "b" `Lowright "gamma" "beta";
   transition states "c" `Top ~outd:25. ~ind:335. "alpha" "beta";
   transition states "d" `Bot ~outd:205. ~ind:155. "beta" "alpha";
   loop states "e" `Bot "gamma";
   initial states `Left "alpha"]
\end{ocaml}
\end{minipage}

% blocs mémoire (listes, etc.) -- JCF

% diagramme simple -- JK

% diagramme UML -- JK
\begin{minipage}{0.3\linewidth}
  \includegraphics{uml.mps}
\end{minipage}
\begin{minipage}{0.3\linewidth}
\small\begin{ocaml}
let uml = 
  let classblock name attr_list method_list = 
    let tex = Box.tex ~stroke:None in
    let vbox = Box.vbox ~pos:`Left in
      Box.vblock ~pos:`Left ~name
      [ tex ("{\\bf " ^ name ^ "}");
        vbox (List.map tex attr_list); vbox (List.map tex method_list) ]
  in
  let a = classblock "BankAccount" 
            [ "balance : Dollars = $0$"] 
            ["deposit (amount : Dollars)"; "withdraw (amount : Dollars)" ] 
  in
  let b = classblock "Client" ["name : String"; "address : String" ] [] in
  let diag = Box.vbox ~padding:(Num.bp 50.) [a;b] in
  [ Box.draw diag; 
    box_label_arrow ~pos:`Left (Picture.tex "owns") 
      (get "Client" diag) (get "BankAccount" diag) ]
\end{ocaml}
\end{minipage}

% arbre -- JCF

% plot -- SL

\begin{minipage}{0.3\linewidth}
  \includegraphics{graph_sqrt.mps}
\end{minipage}
\begin{minipage}{0.3\linewidth}
\small\begin{ocaml}
let graph_sqrt =
  let u = cm 1. in
  let sk = Plot.mk_skeleton 4 2 u u in
  let label = Picture.tex "$\\sqrt x$", `Top, 3 in
  let graph = Plot.draw_func ~label (fun x -> sqrt (float x)) sk in
    [graph; Plot.draw_simple_axes "$x$" "$y$" sk]
\end{ocaml}
\end{minipage}

% exemples utilisant des calculs en Caml

% bresenham -- JCF

% exemples Florence et Yannick (sans le code)

\section{Architecture logicielle}\label{archi}

% schéma de l'architecture
\begin{figure}[h]
  \begin{center}
    \includegraphics{architecture.mps}
  \end{center}
  \caption{Architecture de \mlpost}
\end{figure}

API
\subsection{Types primitifs de \metapost}


La couche de bas niveau de \mlpost est une interface fidèle à \metapost. Elle
comporte donc tous les types de base de \metapost :

\begin{description}

  \item[Le type numérique (module \texttt{Num})] représente des longueurs.
    Moralement, ce type peut être assimilé au type \texttt{float} en \ocaml,
    mais certaines valeurs (par exemple la taille d'un élément \LaTeX) ne sont
    pas connues à l'exécution.  La plupart des calculs sont donc effectués de
    manière symbolique et le type \texttt{Num.t} doit être abstrait.

  \item[Le type couple ou pair (module \texttt{Point})] représente des points
    dans l'espace à deux dimensions. Pour les mêmes raisons que les
    numériques, les points ne sont pas simplement des pairs de flottants, mais
    doivent être représentés de manière symbolique. 

  \item[Les chemins (module \texttt{Path})] sont des lignes représentés par
    des courbes de Bézier. Ils sont à la base de tout dessin \metapost. Toutes
    les possibilités de construction de chemin dans \metapost\ ont été
    interfacées. On peut dessiner des lignes droites ou des lignes courbes en
    précisant les angles de départ et arrivée, la tension de la courbe, etc.
    
  \item[Les transformations (module \texttt{Transform})] permettent
    d'appliquer une transformation linéaire à un objet quelconque. Il est
    ainsi possible de déplacer des objets, de les agrandir ou étirer, les
    faire tourner ou encore combiner toutes ces transformations.

  \item[Les plumes (module \texttt{Pen})] permettent de choisir une autre
    épaisseur ou une autre forme de stylo, par exemple pour dessiner des
    chemins.

  \item[Les figures (module \texttt{Picture})] permettent de regrouper une
    partie du dessin. Celle-ci peut être un élément \LaTeX, une suite de
    commandes de dessin ou encore un dessin découpé à l'aide d'une surface
    décrite par un chemin clos. Ceci permet de traiter une figure
    arbitrairement complexe comme un objet de base que l'on peut copier,
    transformer, \ldots.

\end{description}
Les autres types \metapost\ (chaînes de caractère, booléen, couleur) sont
facilement représentés en \ocaml. 

\paragraph{Dépendances circulaires}
Cette partie de bas niveau de \mlpost\ présente néanmoins quelques
difficultés. Premièrement, la plupart des modules présentés sont {\em a
priori} mutuellement récursifs : par exemple, les transformations s'appliquent
à tous les autres objets, donc chaque module contient une fonction
\begin{ocaml}
  val transform : Transform.t -> t -> t
\end{ocaml}
où le type \texttt{t} représente le type principal du module en question.
D'un autre côté, les transformations sont construits à l'aide de numériques et
points:
\begin{ocaml}
  val shifted : Point.t -> t
\end{ocaml}
où \texttt{t} est le type des transformations.  Les dépendances circulaires
existent aussi entre types et sont aggravées par la représentation symbolique
des objets ( par exemple, la fonction \texttt{xpart} dans le module
\texttt{Point}). 

Nous voulions présenter les interfaces de \mlpost\ avec des dépendances
circulaires. Or, \ocaml\ ne permet pas de dépendances circulaires entre des
fichiers. Notre solution consiste à définir tous les types dans un seul
fichier, appellons le \texttt{types.mli}. Chaque module fait maintenant
référence à ce fichier. Par exemple, dans le fichier \texttt{path.ml}, qui
fournit l'implémentation du module \texttt{Path}, on trouvera
\begin{ocaml}
  module t = Types.path
\end{ocaml}
Aucun de ces modules ne possède un fichier d'interface \texttt{.mli}. La
dépendance circulaire entre les modules est alors cassée, de manière très
classique.

Comment peut-on réintroduire la circularité (voulue) dans l'interface ? Nous
avons écrit un fichier \texttt{mlpost.mli} qui contient les définitions des
signatures des modules à exporter:
\begin{ocaml}
module rec Num : sig
  type t
  ...
end
and Point : sig
  type t
  ...
end
and Path : sig
  type t
  ...
end
...
\end{ocaml}
Afin de pouvoir écrire ces signatures, tous ces modules sont déclarés de
manière mutuellement récursive. La signature de \texttt{Point} peut ainsi
faire référence à \texttt{Path} et inversement. Maintenant il suffit de
fournir les implémentations de ces modules, à l'aide des fichiers
\texttt{num.ml}, \texttt{point.ml} etc, qui ont tous été compilés et mis dans
un {\em pack}. Cet agencement est très pratique aussi pour la documentation.
C'est uniquement le fichier \texttt{mlpost.mli} qui sert d'entrée pour l'outil
\texttt{ocamldoc}.

\paragraph{Hashconsing et traduction vers \metapost}
compilation, hashconsing

\subsection{Boîtes}

- principe récursif : boîte = picture ou ensemble de boîtes + contour
+ fond

- boîtes primitives
- réunion, alignements

\subsubsection{Application : arbres}

\subsection{Flèches} %%% RB

\section{Conclusion}\label{conclusion}

% pas fait / à faire

résolution d'équations

perspectives infinies d'extensions : 3D, animations, ...
plus facile de le faire en Caml qu'en \metapost\ ou en \LaTeX\ (\tikz,
\pstricks) 

plein de sortes de flèches

\paragraph{Remerciements.} Les auteurs tiennent à remercier Florence
Plateau, Yannick Moy et Claude Marché pour leur contribution à \mlpost.

% La bibliographie
% N'oubliez pas de l'inclure lors de votre soumission.
\bibliographystyle{plain}
\bibliography{./biblio}

\vfill

\pagebreak
\thispagestyle{colloquetitle}
\cleardoublepage
\end{document}

% Local Variables:
% coding: iso-latin-1
% ispell-local-dictionary: "francais"
% End:
