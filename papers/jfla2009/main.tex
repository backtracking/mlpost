\documentclass[twoside]{article}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{actes,alltt,url,graphicx}
\usepackage[french]{babel}
\usepackage{mflogo} 
\usepackage{tikz}
%; whizzy subsection -pdf . 

% macros
\newcommand{\ocaml}{OCaml}
\newcommand{\camllight}{Caml Light}
\newcommand{\asymptote}{Asymptote}
\newcommand{\mlpost}{\textsc{Mlpost}}
\newcommand{\metapost}{\MP}
\newcommand{\fmpost}{\textit{functional} \metapost}
\newcommand{\metafont}{\MF}
\newcommand{\nomdetikz}{Tikz}
\newcommand{\pstricks}{\textsc{Pstricks}}
\newcommand{\dia}{Dia}
\newcommand{\xfig}{\textsc{Xfig}}
\newcommand{\postscript}{PostScript}
\newcommand{\mlpictex}{mlP\hspace{-0.2em}\raisebox{-0.2em}{i}\hspace{-0.1em}c\hspace{-0.1em}\TeX}

\title{Faire bonne figure avec \mlpost}

\author{R. Bardou$^1$
        \& J. Kanig$^1$
        \& J.-C. Filliâtre$^1$
        \& S. Lescuyer$^1$}

\titlehead{Faire bonne figure avec \mlpost}%  a droite (page impaire)

\authorhead{Bardou \& Kanig \& Filliâtre \& Lescuyer}% a gauche (page paire)

\affiliation{\begin{tabular}{rr} 
\\ 1:  ProVal / INRIA Saclay -- Île-de-France
\\     91893 Orsay Cedex, France
\\     LRI / CNRS -- Université Paris Sud
\\     91405 Orsay Cedex, France
\\     {\tt \{bardou,kanig,filliatr,lescuyer\}@lri.fr} 
\end{tabular}}

\begin{document}
\setcounter{page}{1}
\maketitle

\begin{abstract}
  
\end{abstract}

%TODO? : expliquer comment fait \metapost pour inclure du \LaTeX

\section{Introduction}

Lors de la rédaction de documents à nature scientifique (articles,
cours, livres, etc), il est très souvent nécessaire de réaliser des
figures. Ces figures permettent d'agrémenter le texte en illustrant
aussi bien les objets dont il est question dans le document que les
liens qui existent entre eux et facilitent ainsi leur compréhension.
Elles sont donc un composant fondamental au caractère didactique de
tels documents, mais leur réalisation est souvent fastidieuse. En
particulier, il est souvent nécessaire d'y inclure des éléments mis en
forme par \LaTeX (formules, etc), ce que bon nombre de logiciels de
dessin ne permettent pas.
% Il faudrait d'ailleurs déjà que ces logiciels de dessin soient vectoriels
% ce qui n'est pas forcément le cas.

Il existe plusieurs familles d'outils pour réaliser des figures à
intégrer dans un document \LaTeX~:
\begin{itemize}
\item des interfaces graphiques disposant d'une sortie \LaTeX, telles
  que \dia~\cite{dia} ou \xfig~\cite{xfig} ;
\item des bibliothèques \LaTeX, telles que \pstricks~\cite{pstricks}
  ou encore \nomdetikz~\cite{tikz} ; 
\item des outils externes en ligne de commande, tel 
  \metapost~\cite{metapost}.
\end{itemize}

Chaque famille a ses avantages et ses inconvénients. Les interfaces
graphiques sont les plus accessibles, notamment pour un placement
rapide et intuitif des différents éléments de la figure, mais
l'intégration de texte mis en forme par \LaTeX\ est délicate. Dans le
cas de \xfig\ et de \dia, la taille des éléments \LaTeX\ n'est pas
connue lors de l'édition de la figure ; en outre, dans le cas de \dia,
l'intégration de \LaTeX\ dans une figure nécessite de l'exporter sous
forme de macros \nomdetikz\ et d'éditer le résultat.

Les bibliothèques \LaTeX\ telles que \pstricks\ ou \nomdetikz\ offrent
l'intégration la plus naturelle avec \LaTeX. En particulier, elles
permettent de combiner arbitrairement éléments graphiques et textes
\LaTeX\ \begin{tikzpicture}[baseline=(a.base)]
\path[use as bounding box] 
  (0,0) node[draw,style=dashed] (a) {comme ceci};
\draw[->] (a) .. controls +(-2cm,1cm) and +(-2cm,-0cm) .. (a);
\end{tikzpicture}.
En revanche, elles demandent d'apprendre un certain nombre de
macros et de notations et souffrent surtout des défauts inhérents à
\LaTeX~:
\begin{itemize}
\item des erreurs détectées uniquement à
  l'interprétation, peu claires et parfois mal localisées ;
\item un langage \emph{de programmation} peu commode (syntaxe obscure,
  absence de typage, code difficile à structurer).
\end{itemize}
Ces inconvénients sont notamment un frein au développement de
bibliothèques de haut niveau au dessus de ces langages ainsi qu'à la
réutilisation de figures.

\metapost\ se présente comme une alternative à ces bibliothèques
\LaTeX, en proposant un langage de programmation à part entière
spécialisé dans la construction de figures contenant des éléments
\LaTeX. Il permet notamment de manipuler symboliquement la taille et
la position de ces éléments et de les relier de manière implicite par
des équations. En revanche, le langage de \metapost\ s'inspire de
celui de \metafont~\cite{metafont} et présente, à l'exception de la
syntaxe, les défauts soulevés ci-dessus. La figure~\ref{fig:metapost}
donne un exemple de programme/figure réalisé avec \metapost.
\begin{figure}[h]
\begin{minipage}{.3\linewidth}
  \includegraphics{figmp.mps}
\end{minipage}
\begin{minipage}{.7\linewidth}
\small
\begin{alltt}
  vardef koch(expr A,B,n) =
    save C; pair C; C = A rotatedaround(1/3[A,B], 120);
    if n>0:
      koch( A,        1/3[A,B], n-1);
      koch( 1/3[A,B], C,        n-1);
      koch( C,        2/3[A,B], n-1);
      koch( 2/3[A,B], B,        n-1);
    else:
      draw A--1/3[A,B]--C--2/3[A,B]--B;
    fi;
  enddef;
  z0=(4cm,0); z1=z0 rotated 120; z2=z1 rotated 120;
  koch( z0, z1, 4 ); koch( z1, z2, 4 ); koch( z2, z0, 4 );
\end{alltt}
\end{minipage}
\caption{Exemple de figure \metapost}\label{fig:metapost}
\end{figure}
Dans un souci d'exhaustivité, nous devons aussi mentionner
\asymptote\cite{asymptote}, également un langage dédié à la création
de figures. Nous n'allons pas rentrer dans les détails de cet outil
car nous ne considéront plus les langages dédiés par la suite.

Une alternative séduisante aux solutions précédentes consiste à
utiliser un langage de programmation existant. Ainsi l'utilisateur n'a
pas à apprendre un langage spécialisé et il bénéficie d'autre part de
tous les avantages d'un langage de programmation moderne : erreurs
détectées à la compilation, types de données complexes, structuration, etc.
Toute la difficulté réside alors dans la manipulation des éléments
\LaTeX, notamment la prise en compte de leur taille dans l'élaboration
de la figure. Si on considère la famille des langages fonctionnels, on
peut citer au moins deux exemples de telle intégration :
\begin{itemize}
\item \mlpictex~\cite{mlpictex} est\footnote{À notre connaissance,
    \mlpictex\ n'est plus distribué.} un ensemble de macros \LaTeX\ permettant
  d'inclure du code \camllight\ arbitraire dans un document \LaTeX.
  Ce code s'appuie sur une bibliothèque de dessin \postscript\ et peut
  faire référence à des éléments \LaTeX, ainsi qu'à leur taille.

\item \fmpost~\cite{fmpost} est une bibliothèque Haskell produisant du
  code \metapost. C'est une approche légère qui réutilise les
  capacités graphiques de \metapost\ et ne fait que changer le langage
  de programmation.
\end{itemize}
C'est cette dernière approche qu'adopte \mlpost.

\medskip

Cet article est organisé de la manière suivante. 
La section~\ref{exemples} ...
La section~\ref{archi} ...
Enfin, la section~\ref{conclusion} ...

%%% CONS

% pas de baseline

% pas de mélange entre LaTeX et les graphiques


\section{Principes et exemples}\label{exemples}

Les briques de base de \mlpost\ sont les boîtes : Un objêt de dessin, entouré
d'un trait, visible ou non. On peut construire la boîte vide, des boîtes avec
du \LaTeX arbitraire, etc. Ces boîtes peuvent ensuite être manipulées :
imbrication arbitraire, placement à une position précise, alignement de
plusieurs boîtes, tabularisation. Des boîtes peuvent aussi être groupées pour
les déplacer ensemble.

Un premier choix à faire est celui de la persistance : Quand on modifie un
attribut (positionnement, couleur etc.), on obtient une nouvelle boîte,
identique à la première sauf en l'attribut changé. L'ancienne boîte est elle
encore accessible, avec ses attributs inchangés, ou bien a-t-elle été détruite
? Nous avons fait le choix des structures de données persistantes,
c'est-à-dire, l'ancienne boîte est préservée. Cela a l'avantage de pouvoir
réutiliser plus facilement une boîte à plusieurs endroits différents du
dessin, avec des attributs différents. En déplacant une boîte, on en a créé
une nouvelle en laissant l'ancienne à sa place.

Un autre principe de Mlpost consiste à placer les objets de façon
relative plutôt qu'absolue.  Ceci permet d'obtenir des figures plus
robustes. En effet, imaginons que vous vouliez placer une boîte $A$ à
\emph{droite} d'une boîte $B$.  Une première possibilité serait de
spécifier les positions approximativement, par exemple en donnant les
abscisses $0cm$ pour $A$ et $2cm$ pour $B$. Mais si vous changez
d'avis sur le contenu de $A$ et que la taille de la boîte change, $A$
risque alors de se superposer à $B$. Il faut alors replacer toutes les
boîtes de votre figure. Pour éviter ça, \mlpost\ propose diverses
méthodes pour placer les boîtes \emph{les unes par rapport aux
  autres}. On gagne alors du temps lors de la création et lors des
modifications de la figure.
%TODO exemple ici => a développer dans la section Boites de tte façon

% automate -- RB
\subsection{Automates}

\label{sec:automates}
L'un des principes de  \mlpost\ est la possibilité d'écrire facilement
des librairies. Par exemple, si  vous étudiez la théorie des langages,
vous  pouvez   écrire  une   librairie  spécialisée  dans   le  dessin
d'automates.   Une façon  de  faire consiste  à  écrire les  fonctions
suivantes :
\begin{itemize}
\item \texttt{state} pour créer un état ;
\item \texttt{initial} pour transformer un état en un état initial ;
\item \texttt{final} pour transformer un état en un état final ;
\item \texttt{transition} pour dessiner une transition d'un état à un autre ;
\item \texttt{loop} pour dessiner une transition d'un état vers lui-même.
\end{itemize}

La  fonction \texttt{state}  renvoie simplement  une boîte  au contour
circulaire, à placer où  on veut.  La fonction \texttt{final} consiste
à  rajouter  un  deuxième   cercle  autour  d'un  état.   En  première
approximation, il  suffit donc  de placer cet  état dans  une deuxième
boîte circulaire. La fonction \texttt{final} est donc une fonction qui
prend une boîte et qui renvoie une boîte.
\begin{ocaml}
let state = Box.tex ~style:Circle 
let final = Box.box ~style:Circle ~dx:zero ~dy:zero 
\end{ocaml}
Les paramètres \texttt{dy} et  \texttt{dy} permettent de spécifier une
marge  entre le  contenu de  la boîte  et son  contour. Notez  que les
fonctions  \texttt{Box.tex} et  \texttt{Box.box} prennent  un argument
\texttt{name}  permettant de  nommer les  boîtes pour  y  accéder plus
tard.

La  fonction \texttt{initial} doit  apposer une  flèche entrante  à un
état.  Il  s'agit donc  d'une fonction  qui prend un  état $q$  et qui
renvoie une commande dessinant une  flèche vers $q$. On pourrait aussi
renvoyer une  boîte sans  contour contenant $q$  et la flèche,  ce qui
permettrait   d'utiliser  \texttt{initial}  de   la  même   façon  que
\texttt{final}.   Cependant, la  boîte  obtenue n'aurait  pas la  même
taille et  la même forme que  $q$, ce qui poserait  des problèmes pour
placer $q$ ou pour dessiner des transitions vers ou à partir de $q$.
\begin{ocaml}
let initial states pos name =
  let x = Box.get name states in
  let p = match pos with
    | `Left -> Box.west x
    | `Right -> Box.east x
    | `Top -> Box.north x
    | `Bot -> Box.south x
  in
  Arrow.draw (Path.pathp [ Point.shift p (Point.pt (cm (-0.3), zero)); p ])
\end{ocaml}
La fonction  accède à  la boîte \texttt{x}  par son  nom \texttt{name}
dans la  boîte \texttt{states}, qui  doit être une boîte  englobant en
particulier l'état désigné par \texttt{name}.

On peut maintenant  placer des états, initiaux ou  non, finaux ou non,
et  les  dessiner.   Pour  le  placement,  on  utilise  les  fonctions
d'alignement    horizontal    et    vertical   \texttt{Box.hbox}    et
\texttt{Box.vbox}. On  suit donc le  principe consistant à  placer les
objets de façon relative, les uns par rapport aux autres.

\begin{minipage}{0.2\linewidth}
  \includegraphics{automate_1.mps}
\end{minipage}
\begin{minipage}{0.2\linewidth}
\begin{ocaml}
let automate =
  let states = Box.vbox ~padding: (cm 0.8)
    [ Box.hbox ~padding: (cm 1.4)
      [ state ~name: "alpha" "$\\alpha$";
        state "$\\beta$" ];
      final (state "$\\gamma$") ]
  in
  [ Box.draw states;
    initial states `Left "alpha" ]
\end{ocaml}
\end{minipage}

La fonction  \texttt{transition} doit dessiner une flèche  d'un état à
un autre. Cette fonction prend deux arguments optionnels \texttt{outd}
et \texttt{ind} pour spécifier, en degrés, la direction sortante et la
direction entrante  de la  flèche. On doit  les convertir  en vecteurs
directeurs  pour les passer  à \texttt{cpath},  qui calcule  un chemin
allant d'un bord d'une boîte au  bord d'une autre boîte. Ce chemin est
ensuite donné à la fonction \texttt{Arrow.draw} qui trace la flèche en
plaçant une étiquette \texttt{tex} à la position \texttt{pos}.
\begin{ocaml}
let transition states tex pos ?outd ?ind x_name y_name = 
  let x = Box.get x_name states and y = Box.get y_name states in
  let outd = match outd with None -> None | Some a -> Some (vec (dir a)) in
  let ind = match ind with None -> None | Some a -> Some (vec (dir a)) in
  Arrow.draw ~tex ~pos (cpath ?outd ?ind x y) 
\end{ocaml}

La    fonction   \texttt{loop}   est    similaire   à    la   fonction
\texttt{transition},   mais  elle   doit  calculer   un   chemin  plus
complexe. En  effet, \texttt{cpath} appliqué à  deux boîtes identiques
renvoie un chemin vide et on  ne peut donc pas l'utiliser. A la place,
on calcule un point $A$ suffisamment  éloigné de la boîte, et on trace
un chemin  qui part du centre, qui  passe par $A$ puis  qui revient au
centre.

\begin{minipage}{0.2\linewidth}
  \includegraphics{loop_explain.mps}
\end{minipage}
\begin{minipage}{0.2\linewidth}
\small\begin{ocaml}
let loop states tex pos name =
  let box = Box.get name states in
  let fdir, angle, x, y = match pos with
    | `Top -> Box.north, 0., 0., 0.4
    | `Left -> Box.west, 90., (-0.4), 0.
    | `Bot -> Box.south, 180., 0., (-0.4)
    | `Right -> Box.north, 270., 0.4, 0.
  in
  let a = Point.shift (fdir box) (Point.pt (cm x, cm y)) in
  let c = Box.ctr box in
  let p = Path.pathk [
    knotp ~r: (vec (dir (angle +. 45.))) c;
    knotp a;
    knotp ~l: (vec (dir (angle -. 45.))) c;
  ] in
  let bp = Box.bpath box in
  Arrow.draw ~tex ~pos: (pos :> Command.position)
    (cut_after bp (cut_before bp p))
\end{ocaml}
\end{minipage}

On  peut maintenant  dessiner  facilement des  automates en  utilisant
cette librairie.

\begin{minipage}{0.2\linewidth}
  \includegraphics{automate.mps}
\end{minipage}
\begin{minipage}{0.2\linewidth}
\small\begin{ocaml}
let automate =
  let states = Box.vbox ~padding: (cm 0.8)
    [ Box.hbox ~padding: (cm 1.4)
        [ state ~name: "alpha" "$\\alpha$";
          state ~name: "beta" "$\\beta$" ];
      final ~name: "gamma" (state "$\\gamma$") ]
  in
  [ Box.draw states;
    transition states "a" `Lowleft "alpha" "gamma";
    transition states "b" `Lowright "gamma" "beta";
    transition states "c" `Top ~outd: 25. ~ind: 335. "alpha" "beta";
    transition states "d" `Bot ~outd: 205. ~ind: 155. "beta" "alpha";
    loop states "e" `Bot "gamma";
    initial states `Left "alpha" ]
\end{ocaml}
\end{minipage}

\subsection{Diagrammes}

Le but de cette section est de montrer l'importance d'une possibilité de
placement relatif . Nous décrivons plusieurs exemples de mini-bibliothèques
qui exploitent cette possibilité.

\paragraph{Représentation de la mémoire}
% blocs mémoire (listes, etc.) -- JCF
% introduire Box.vblock

\paragraph{Diagrammes de classes}

Avec la fonction \texttt{Box.vblock} vue auparavant, il est facile
d'implémenter une fonction qui dessine un rectangle correspondant à
une classe :
\begin{ocaml}
let classblock name attr_list method_list = 
  let tex = Box.tex ~stroke:None in
  let vbox = Box.vbox ~pos:`Left in
    Box.vblock ~pos:`Left ~name
    [ tex ("{\\bf " ^ name ^ "}");
      vbox (List.map tex attr_list); vbox (List.map tex method_list)
    ]
\end{ocaml}
\texttt{classblock} est une fonction qui attend le nom de la classe
ainsi que la liste des attributs et des méthodes. Ici, le nom
\texttt{name} de la classe est utilisé à la fois pour désigner le
schéma dans le diagramme (l'argument labelisé à \texttt{Box.vblock})
et comme titre du schéma créé. Les attributs et les méthodes sont alignés
verticalement séparément, et après on aligne le titre et les deux nouvelles
boîtes obtenues en les encadrant. On obtient avec peu d'effort une fonction
qui crée un bloc d'une classe.

On peut maintenant s'en servir pour dessiner un petit diagramme de classes :

\begin{minipage}{0.3\linewidth}
  \includegraphics{uml.mps}
\end{minipage}
\begin{minipage}{0.3\linewidth}
\small\begin{ocaml}
let uml = 
  let a = classblock "BankAccount" 
            [ "balance : Dollars = $0$"] 
            ["deposit (amount : Dollars)"; 
             "withdraw (amount : Dollars)" ] 
  in
  let b = classblock "Client" ["name : String"; 
                               "address : String" ] [] in
  let diag = Box.vbox ~padding:(cm 1.) [a;b] in
  [ Box.draw diag; 
    box_label_arrow ~pos:`Left (Picture.tex "owns") 
      (get "Client" diag) (get "BankAccount" diag) ]
\end{ocaml}
\end{minipage}
\vspace{1em}

Ici, on a d'abord créé deux schémas de classe avec la fonction
\texttt{classblock}. Ces schémas sont ensuite alignés verticalement, et une
flèche avec une étiquette est dessinée entre ces deux classes. En tout, le
code pour cette figure est conceptuellement très simple, contient aucun
placement absolu et ne dépasse pas les 20 lignes de code.


\subsection{Autres extensions : arbres et graphes de fonctions}

% arbre -- JCF

% plot -- SL

\begin{minipage}{0.3\linewidth}
  \includegraphics{graph_sqrt.mps}
\end{minipage}
\begin{minipage}{0.3\linewidth}
\small\begin{ocaml}
let graph_sqrt =
  let u = cm 1. in
  let sk = Plot.mk_skeleton 4 2 u u in
  let label = Picture.tex "$\\sqrt x$", `Top, 3 in
  let graph = Plot.draw_func ~label (fun x -> sqrt (float x)) sk in
    [graph; Plot.draw_simple_axes "$x$" "$y$" sk]
\end{ocaml}
\end{minipage}

% exemples utilisant des calculs en Caml

% bresenham -- JCF

% exemples Florence et Yannick (sans le code)

\section{Architecture logicielle}\label{archi}

\begin{figure}[hptb]
\begin{center}
\includegraphics{stages.mps}
\end{center}
  \caption{Architecture de \mlpost}\label{fig:etapes}
\end{figure}

Figure~\ref{fig:etapes} montre le fonctionnement de \mlpost.  Tout d'abord,
\mlpost\ est un outil de génération de fichier \metapost\ en forme de
bibliothèque \ocaml. À l'aide de cette bibliothèque, l'utilisateur écrit, sans
forcément le savoir, un programme qui, à l'exécution, construit un arbre de
syntaxe abstraite \metapost. Cet arbre est imprimé dans un fichier
\verb|figure.mp| qui est lu par \metapost\ pour générer un fichier
\postscript\ de sortie, \verb|figure.1|\footnote{ce fichier n'a pas le suffix
.ps puisque ce n'est pas un fichier \postscript proprement dit : il manque
l'entête.}. Pour inclure cette figure dans un document \LaTeX, il suffit
d'utiliser la commande \verb|\includegraphics|.


Nous espérons avoir convaincu le lecteur des avantages que la présentation
sous forme de bibliothèque apporte : familiarité avec le langage pour ceux qui
connaissent \ocaml, typage fort, des construction de programmation de
haut-niveau etc.  Mais ce choix implique également que le fichier \metapost\
de sortie ne sera pas obtenu par une {\em compilation} du code source
proprement dite, mais par une exécution du programme qui construit un arbre de
syntaxe abstraite (AST). Cette méthode a l'inconvénient qu'une boucle ou
itération dans le programme de départ sera traduite par une suite de commandes
obtenues par le déroulement de la boucle, et non par une construction de
boucle du langage cible. Ceci étant dit, dans notre cas, le coût
supplémentaire est faible, puisque \metapost\ déroule aussi les boucles dans
les fichiers \postscript\ de sortie. 
%TODO est-ce trop détaillé / le bon endroit ?

% schéma de l'architecture
\begin{figure}[htpb]
  \begin{center}
    \includegraphics{architecture.mps}
  \end{center}
  \caption{Architecture de \mlpost}\label{fig:archi}
\end{figure}

L'architecture générale de \mlpost{} est schématisée en
figure~\ref{fig:archi}. Au niveau le plus bas se trouvent les interfaces
correspondant aux types primitifs de \metapost. Ce sont ces objets qui sont
{\it in fine} traduits en du code \metapost, et nous les décrivons de manière
plus détaillée dans la section~\ref{subsec:types}. La couche intermédiaire
contient des éléments que nous estimons être de bas niveau mais qui ne sont
pas présents dans \metapost : ils sont propres à \mlpost\ et ont été
construits à partir de la couche inférieure. Les sections~\ref{subsec:boxes}
et \ref{subsec:arrows} reviennent plus en détail sur deux de ces modules,
respectivement \texttt{Box} et \texttt{Arrow}.

\subsection{Types primitifs de \metapost}\label{subsec:types}

La couche de bas niveau de \mlpost est une interface fidèle à \metapost. Elle
comporte donc tous les types de base de \metapost :

\begin{description}

  \item[Le type numérique (module \texttt{Num})] représente des longueurs.
    Moralement, ce type peut être assimilé au type \texttt{float} en \ocaml,
    mais certaines valeurs (par exemple la taille d'un élément \LaTeX) ne sont
    pas connues à l'exécution.  La plupart des calculs sont donc effectués de
    manière symbolique et le type \texttt{Num.t} doit être abstrait.

  \item[Le type couple ou pair (module \texttt{Point})] représente des points
    dans l'espace à deux dimensions. Pour les mêmes raisons que les
    numériques, les points ne sont pas simplement des pairs de flottants, mais
    doivent être représentés de manière symbolique. 

  \item[Les chemins (module \texttt{Path})] sont des lignes représentés par
    des courbes de Bézier. Ils sont à la base de tout dessin \metapost. Toutes
    les possibilités de construction de chemin dans \metapost\ ont été
    interfacées. On peut dessiner des lignes droites ou des lignes courbes en
    précisant les angles de départ et arrivée, la tension de la courbe, etc.
    
  \item[Les transformations (module \texttt{Transform})] permettent
    d'appliquer une transformation linéaire à un objet quelconque. Il est
    ainsi possible de déplacer des objets, de les agrandir ou étirer, les
    faire tourner ou encore combiner toutes ces transformations.

  \item[Les plumes (module \texttt{Pen})] permettent de choisir une autre
    épaisseur ou une autre forme de stylo, par exemple pour dessiner des
    chemins.

  \item[Les figures (module \texttt{Picture})] permettent de regrouper une
    partie du dessin. Celle-ci peut être un élément \LaTeX, une suite de
    commandes de dessin ou encore un dessin découpé à l'aide d'une surface
    décrite par un chemin clos. Ceci permet de traiter une figure
    arbitrairement complexe comme un objet de base que l'on peut copier,
    transformer, \ldots.

\end{description}
Les autres types \metapost\ (chaînes de caractères, booléens, couleurs)
sont facilement représentés en \ocaml. L'interface de \mlpost\ contient
aussi un module \texttt{Command} qui définit le type des commandes
\metapost : commandes de dessin, de remplissage, itération et séquences
etc.

\paragraph{Dépendances circulaires}
Cette partie de bas niveau de \mlpost\ présente néanmoins quelques
difficultés. Premièrement, la plupart des modules présentés sont {\em
  a priori} mutuellement récursifs : par exemple, les transformations
s'appliquent à tous les autres objets, donc chaque module contient une
fonction
\begin{ocaml}
  val transform : Transform.t -> t -> t
\end{ocaml}
où le type \texttt{t} représente le type principal du module en
question.  D'un autre côté, les transformations sont elles-mêmes
construites à l'aide de numériques et de points:
\begin{ocaml}
  val shifted : Point.t -> t
\end{ocaml}
où \texttt{t} est le type des transformations.  Des dépendances
circulaires existent aussi entre types et sont aggravées par la
représentation symbolique des objets (par exemple, les projections
\texttt{xpart} et \texttt{ypart} du module \texttt{Point} doivent
retourner des numériques et non des flottants).

Nous voulions présenter les interfaces de \mlpost\ avec des
dépendances circulaires mais \ocaml\ ne permet pas de dépendances
circulaires entre des fichiers. Notre solution consiste à définir tous
les types dans un seul fichier, qu'on appelle \texttt{types.mli}.
Chaque module fait maintenant référence à ce fichier. Par exemple,
dans le fichier \texttt{path.ml}, qui fournit l'implémentation du
module \texttt{Path}, on trouvera
\begin{ocaml}
  type t = Types.path
\end{ocaml}
Aucun de ces modules ne possède un fichier d'interface \texttt{.mli}. La
dépendance circulaire entre les modules est alors cassée, de manière très
classique.

Il nous reste alors à réintroduire la circularité recherchée dans
l'interface externe. Nous avons pour ce faire écrit un fichier
\texttt{mlpost.mli} qui contient les définitions des signatures des
modules à exporter :
\begin{ocaml}
module rec Num : sig
  type t
  ...
end
and Point : sig
  type t
  val xpart : t -> Num.t
  ...
end
and Path : sig
  type t
  ...
end
...
\end{ocaml}
Afin de pouvoir écrire ces signatures, tous ces modules sont en
particulier déclarés de manière mutuellement récursive. La signature
de \texttt{Point} peut ainsi faire référence à \texttt{Path} et
inversement. Il suffit alors de fournir les implémentations de ces
modules, à l'aide des fichiers \texttt{num.ml}, \texttt{point.ml} etc,
qui ont tous été compilés et mis dans un {\em pack}. Cet agencement
est également très pratique pour la documentation de l'API: c'est
uniquement le fichier \texttt{mlpost.mli} qui sert d'entrée à
l'outil \texttt{ocamldoc}.

\paragraph{Hashconsing et traduction vers \metapost}

Le choix d'une représentation symbolique de la plupart des objets impose
des efforts supplémentaires pour minimiser l'utilisation de la mémoire
et la taille des fichiers \metapost\ de sortie. En effet, l'arbre de
syntaxe abstraite (AST) contient beaucoup de n\oe uds identiques mais
construits de manière différente, qui prennent donc inutilement de la
place aussi bien en mémoire que dans le fichier \metapost\ généré. C'est
d'autant plus gênant que \metapost\ devra lire ce fichier et passera
donc davantage de temps sur des calculs répétés.

Nous utilisons donc la technique de {\em
hash-consing}~\cite{ConchonFilliatre06wml} appliquée à l'arbre de syntaxe
abstraite. Cette technique permet de partager des valeurs structurellement
égales. Elle utilise une table de hash globale qui stocke toutes les valeurs
déjà créées. Avant de créer un nouvel objet, on regarde dans cette table si un
objet structurellement égal existe déjà. Pour que le calcul de la valeur de
hash ainsi que la comparaison des objets soit efficace, chaque (sous-)terme
vient avec sa valeur de hash. Ainsi, on n'obtient pas seulement le partage de
tous les sous-termes communs, mais également un test d'égalité très efficace,
utile pour toute structure de données contenant ces valeurs : il suffit de
comparer physiquement ces objets.

Cett technique diminue l'utilisation de la mémoire, mais ne change rien {\em a
priori} à la taille des fichiers générés. La structure hash-consée {\em
réalise} le partage, mais elle ne sait pas quels sont les n\oe uds en effet
utilisés au moins deux fois. Pour cela, il suffit de traverser la structure
une fois en entier, en comptant le nombre de fois qu'on a passé chaque n\oe ud
(cette information peut-être stockée efficacement dans une table, à l'aide de
la valeur de hash calculée pour chaque n\oe ud pour le hash-consing ainsi que
la comparaison efficace fournie par ce dernier).  Quand on passe un n\oe ud
déjà rencontré, on ne considère pas ses sous-n\oe uds. Il est néanmoins
possible de rencontrer une nouvelle fois un sous-n\oe ud d'une structure,
comme le montre l'arbe ci-dessous :

\begin{center}
\includegraphics[scale=1.5]{tree.mps}
\end{center}

Dans cette configuration, le n\oe ud $f$ est réellement utilisé deux
fois, alors que le n\oe ud $e$ n'est utilisé qu'un seule fois, par le
n\oe ud $d$, même si celui-ci est utilisé deux fois à son tour.

Après cette analyse, la génération du fichier \metapost\ devient très simple :
il suffit de traverser l'AST encore une fois, et quand on passe par un n\oe ud
qui a été utilisé au moins deux fois, on lui attribue une variable et on
ajoute une définition correspondante dans le code \metapost. Il faut néanmoins
prendre en compte les particularités syntaxiques de \metapost\ telles que la
précédence inhabituelle des opérateurs arithmétiques et la restriction de
l'application de certaines constructions à des variables. De cette façon, on
arrive à avoir du code \metapost\ relativement petit\footnote{En l'absence de
boucles \texttt{for} et de macros dans le code \metapost, nous avons observés,
sans avoir fait de tests très exhaustifs, une taille du code généré similaire
ou pas plus de deux fois plus grand que du code \metapost\ écrit à la main.
}, malgré la délégation des calculs à \metapost.

% TODO : des chiffres pour justifier "relativement petit" ?

\subsection{Boîtes}\label{subsec:boxes}

- principe récursif : boîte = picture ou ensemble de boîtes + contour
+ fond

- boîtes primitives
- réunion, alignements

\paragraph{Application : arbres}



\subsection{Flèches} \label{subsec:arrows} %% RB

\metapost\ ne propose qu'un seul type de flèche :
\begin{center}
\includegraphics{arrow_metapost.mps}
\end{center}
Les  flèches peuvent  suivre  n'importe quel  chemin  et peuvent  être
tracées avec différents styles de  trait, mais il n'y a toujours qu'un
seul trait  et la tête de  flèche est toujours la même. Avec \mlpost,
l'utilisateur peut créer ses propres catégories de flèches.

Le module \texttt{Arrow} dispose de deux types.
\begin{itemize}
\item  Le  type \texttt{head}  décrit  comment  dessiner  une tête  de
  flèche.   Les  éléments de  type  \texttt{head}  sont des  fonctions
  prenant en argument la position et la direction de la tête de flèche
  et renvoyant une commande dessinant la flèche.
\item Le  type abstrait \texttt{kind} décrit une  catégorie de flèche.
  On  part de  la catégorie  vide \texttt{empty},  puis on  ajoute des
  traits et des têtes.
\end{itemize}

La  fonction  \texttt{draw}  permet   de  dessiner  une  flèche  d'une
catégorie donnée  en suivant un  chemin donné. Les flèches  sont alors
dessinées  en   utilisant  les   primitives  de  \metapost.    Ceci  a
l'inconvénient  d'utiliser   plus  de  ressources   mais  nous  permet
d'imaginer de nombreuses catégories de flèches.

On peut émuler les flèches de \metapost. On part d'un corps vide et on
lui ajoute un trait normal sur  toute la longueur.  On ajoute une tête
triangulaire remplie, et on obtient :

\begin{minipage}{0.2\linewidth}
  \includegraphics{arrow_simple.mps}
\end{minipage}
\begin{minipage}{0.2\linewidth}
\begin{ocaml}
let kind =
  Arrow.add_head ~head: Arrow.head_triangle_full
    (Arrow.add_line Arrow.empty)
in [ Arrow.draw ~kind (Path.pathp ...) ]
\end{ocaml}
\end{minipage}

La  section~\ref{sec:automates}  contient   une  figure  décrivant  le
fonctionnement de la fonction \texttt{loop}. Pour les besoins de cette
figure, on  a créé un  type de flèche  spécial, composé d'un  début et
d'une fin en pointillés et avec une tête placée différemment :
\begin{center}
\includegraphics{arrow_loop_explain.mps}
\end{center}
Le code permettant d'obtenir cette  catégorie de flèche est le suivant
:
\begin{ocaml}
let kind =
  Arrow.add_belt ~point: 0.9
    (Arrow.add_line ~dashed: Dash.evenly ~to_point: 0.1
       (Arrow.add_line ~dashed: Dash.evenly ~from_point: 0.9
          (Arrow.add_line ~from_point: 0.1 ~to_point: 0.9
             Arrow.empty)))
\end{ocaml}

\section{Conclusion}\label{conclusion}

% pas fait / à faire

résolution d'équations

perspectives infinies d'extensions : 3D, animations, ...  plus facile
de le faire en Caml qu'en \metapost\ ou en \LaTeX\ (\nomdetikz,
\pstricks)

possibilité de changer de langage de sortie (\nomdetikz\ ou \postscript\
directement, si on implémente une technique similaire à celle de \metapost\
pour l'inclusion de \LaTeX)

plein de sortes de flèches

Toutes les figures de cet article, à l'exception des exemples pour \metapost\
et \nomdetikz\ ont été faites avec \mlpost.

\paragraph{Remerciements.} Les auteurs tiennent à remercier Florence
Plateau, Yannick Moy et Claude Marché pour leur contribution à \mlpost\ et
Sylvie Boldo pour la suggestion du titre de l'article.

% La bibliographie
% N'oubliez pas de l'inclure lors de votre soumission.
\bibliographystyle{plain}
\bibliography{./biblio}

\vfill

\pagebreak
\thispagestyle{colloquetitle}
\cleardoublepage
\end{document}

% Local Variables:
% coding: iso-latin-1
% ispell-local-dictionary: "francais"
% End:
