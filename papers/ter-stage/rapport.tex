\documentclass[a4paper,12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{fullpage,url,graphicx,alltt}

\newcommand{\mlpost}{\textsc{Mlpost}}
\newcommand{\gmlpost}{\textsc{GMlpost}}

\begin{document}

\section{Introduction}

\subsection{Présentation de \mlpost}
\mlpost\ est une interface Objective Caml de Metapost, permettant la création de figures.
\subsubsection{Motivations}
Dans un cadre scientifique, il est très souvent nécessaire d'inclure des figures aux documents (cours, articles).
~\\Une façon très commune de rédiger ces documents est d'utiliser \LaTeX. \LaTeX\ permet l'importation d'images, voire la création, mais ceci reste compliqué, long, et les erreurs sont difficiles à interpréter. Il doit également être possible d'ajouter des éléments de \LaTeX\ à la figure, et de garder une homogénéité du document. 

~\\L'utilisation d'un langage comme OCaml, avec un typage fort et des erreur plus simples à déchiffrer s'imposait donc! De plus, OCaml bénéficie d'arguments optionnels, très pratiques dans la conception d'une librairie graphique.Enfin, la quantité de code tapé devient plus concise, rendant la conception de figures possible d'un simple appel de fonction.

~\\Enfin il est important de préciser qu'une figure \mlpost\ peut être utilisée comme la vue du résultat d'un calcul ou d'un algorithme OCaml. On pourra par exemple calculer un arbre couvrant d'un graphe, et le représenter sous forme d'arbre \mlpost\ dans le même programme.

\subsubsection{Exemples}
Un exemple facile d'utilisation de boîte avec \mlpost. On notera l'utilisation du symbole mathématique $\pi$ qui se fait aisément en conservant l'homogénéité du tout. 
~\\

\begin{minipage}{0.7\linewidth}
  \begin{alltt}
    let simple_block =
    let b = Box.hblock ~pos:`Bot 
    [Box.tex "a"; Box.tex "A"; Box.tex "1"; Box.tex "$\\pi$"] 
    in
    Box.draw b
  \end{alltt}
\end{minipage}
\begin{minipage}{0.3\linewidth}
  \begin{center}
    \includegraphics[scale=2]{simple_block.mps}
  \end{center}
\end{minipage}


Un exemple légèrement plus compliqué dans lequel on utilise des arguments optionnels pour mieux personnaliser la figure.
~\\

\begin{minipage}{0.7\linewidth}
  \begin{alltt}
    let traffic =
    let two = Num.bp 2. in
    let b = 
    vbox ~fill:black ~padding:(Num.bp 3.) ~dx:two ~dy:two
    [ tex ~style:Circle ~fill:red "R";
      tex ~style:Circle ~fill:yellow "Y";
      tex ~style:Circle ~fill:green "G"; ]
    in
    draw b
  \end{alltt}
\end{minipage}
\begin{minipage}{0.3\linewidth}
  \begin{center}
    \includegraphics[scale=2]{traffic.mps}
  \end{center}
\end{minipage}

Un dernier exemple plus compliqué utilisant les module Path, Point et Pen pour dessiner un rubik's cube.
~\\

\begin{minipage}{0.7\linewidth}
  \begin{alltt}
    let alpha = atan 1.
    let beta = atan 1. /. 2. 
    let mag = 10.
    
    let proj x y z = 
    mag *. float (x - y) *. cos alpha, 
    mag *. (float (x + y) *. sin alpha *. sin beta +. float z *. cos beta)
    
    let pen = Pen.scale (bp 2.5) Pen.default
  
    let square color p i j =
    let pt i j = let x,y = p i j in 
    Point.pt (bp x, bp y) in
    let points = [pt i j; pt (i+1) j; 
      pt (i+1) (j+1); pt i (j+1)] in
    let path = pathp ~style:jLine 
    ~cycle:jLine points in
    seq [fill ~color path; Command.draw ~pen path]
    
    let right = square Color.orange (fun i j -> proj i 0 j)
    let up = square Color.yellow (fun i j -> proj i j 3)
    let left = square Color.green (fun i j -> proj 0 (3 - i) j)
    
    let rubik = 
    seq [iter 0 2 (fun i -> iter 0 2 (right i));
      iter 0 2 (fun i -> iter 0 2 (up i));
      iter 0 2 (fun i -> iter 0 2 (left i));]
  \end{alltt}
\end{minipage}
\begin{minipage}{0.3\linewidth}
  \begin{center}
    \includegraphics[scale=3]{rubik.mps}
  \end{center}
\end{minipage}

\subsection{Notre TER}
\subsubsection{Modules au dessus de \mlpost}
\subsubsection{Interface Graphique}

\section{Modules \mlpost}


\subsection{Histogrammes}
Il existe trois types d'histogramme:

\subsubsection{Simple:}
Un histogramme classique construit à partir d'une liste de nombres
flottants.

~\\

\begin{minipage}{0.5\linewidth}
  \begin{alltt}
    let hist = Hist.simple [3.;1.;6.]
  \end{alltt}
\end{minipage}
\begin{minipage}{0.5\linewidth}
  \begin{center}
    \includegraphics[scale=0.5]{hist1.mps}
  \end{center}
\end{minipage}

\subsubsection{Comparatif :} 
Un histogramme comparatif construit à partir d'une liste. Cette liste
contient N listes de nombres flottants, chacune étant un histogramme.

~\\

\begin{minipage}{0.5\linewidth}
  \begin{alltt}
    let hist = Hist.compare
    [[1.;5.;6.;5.;3.];
      [1.;2.;3.;6.;-1.]]
  \end{alltt}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\begin{center}
\includegraphics[scale=0.5]{hist2.mps}
\end{center}
\end{minipage}

\subsubsection{Cumulatif :} 
Un histogramme cumulatif.

~\\

\begin{minipage}{0.5\linewidth}
  \begin{alltt}
    let hist = Hist.stack 
    ~fill:[lightred;lightblue
      ;lightyellow;lightgreen]
    [[4.;5.;5.;]; [8.;3.;1.]; [2.;8.;1.;4.]]
  \end{alltt}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\begin{center}
\includegraphics[scale=0.5]{hist3.mps}
\end{center}
\end{minipage}

\subsubsection{Pour aller plus loin:}
Il est possible de faire des histogrammes bien plus complexes, mais toujours de façon très simple.

~\\

\begin{minipage}{0.5\linewidth}
  \begin{alltt}
    let hist =
    let pics =
    List.map Picture.tex ["2000";"2001";
      "2002";"2003";"2004";"2005"]
    in
    Hist.simple 
    ~histlabel:(`Top, Hist.User pics)
    [4.5;5.0;6.2;8.;7.2;6.1]
  \end{alltt}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\begin{center}
\includegraphics[scale=0.5]{hist4.mps}
\end{center}
\end{minipage}

~\\

\begin{minipage}{0.5\linewidth}
  \begin{alltt}
    let hist = Hist.stack
    ~perspective:true ~padding:(bp 25.)
    ~fill:[lightred;lightblue;
      lightyellow;lightgreen]
    ~histlabel:(`Center, Hist.Values)
    [[4.;5.;5.;]; [8.;3.;1.]; [2.;8.;1.;4.]]
  \end{alltt}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\begin{center}
\includegraphics[scale=0.5]{hist5.mps}
\end{center}
\end{minipage}

\subsection{Radar}
Ce module permet la création de diagrammes radar.
Nous donnons la possibilité d'en créer deux sortes.
Lorsqu'un radar est créé, l'objet \mlpost\ renvoyé est une Picture.
Nous en verrons l'utilité plus tard.

\subsubsection{Cumulatif:}
Le diagramme radar classique. Toutes les données sont regroupées sur la même figure, de façon à les comparer instantanément. 

~\\

\begin{minipage}{0.5\linewidth}
  \begin{alltt}
    let radar =
    let pic =
    Radar.stack
    ~pen:(Pen.scale (bp 3.) Pen.circle)
    ~color:[blue;red;green]
    ~label:["weight";"acceleration";
      "speed";"maniability";"stickiness"]
    [[3.;4.;5.;6.;4.];
      [6.;5.;2.;1.;1.];
      [1.;7.;2.;4.;5.]]
    in
    Command.draw_pic pic
  \end{alltt}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\begin{center}
\includegraphics[scale=0.8]{radar1.mps}
\end{center}
\end{minipage}

\subsubsection{Comparatif}
Contrairement au diagramme précédent, celui ci ne fabrique pas qu'une seule Picture, mais autant qu'il existe d'objets à comparer. Cela permet donc un plus grand choix dans la mise en page.

~\\

\begin{minipage}{0.5\linewidth}
  \begin{alltt}
    let radar =
    let pics =
    Radar.compare
    ~pen:(Pen.scale (bp 1.5) Pen.circle)
    ~color:[lightblue;lightred;lightgreen] 
    ~fill:true
    [[3.;4.;5.;6.;4.];
      [6.;5.;2.;1.;1.];
      [1.;7.;2.;4.;5.]]
    in
    Box.draw (Box.vbox ~padding:(bp 10.) 
    (List.map (Box.pic ~stroke:None) pics))

  \end{alltt}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\begin{center}
\includegraphics[scale=0.5]{radar2.mps}
\end{center}
\end{minipage}

\subsection{Path}
Dans \mlpost, le module Path permet à l'utilisateur de tracer toutes sortes de lignes, qu'elles soient droites ou des courbes de Bézier, et ce par le biais de nombreuses fonctions.
Nous n'avons rien modifié de ce qui était déjà en place. Nous avons seulement ajouter une nouvelle manière de tracer un Path, appelée \textit{smart\_path}. 

~\\Cette fonction prend en paramètre deux points: le point de départ du Path, et le point d'arrivée. 
\begin{alltt}
  val smart_path : ?style:joint -> orientation list -> Point.t -> Point.t -> t
\end{alltt}
~\\La particularité de \textit{smart\_path} est que la fonction prend un troisième paramètre, qui est une liste d'orientations.
~\\Le type orientation se définit comme ceci:
\begin{alltt}
  type orientation =
  Up | Down | Left | Right |
  Upn of Num.t | Downn of Num.t | Leftn of Num.t | Rightn of Num.t
\end{alltt}
Ceci permet à l'utilisateur de choisir la façon dont il veut relier les deux points. Dans la mesure du possible, \mlpost\ créera ce path, ou retournera une erreur. 

~\\exemples d'utilisations de \textit{smart\_path}:

~\\
\begin{minipage}{0.5\linewidth}
  \begin{alltt}
    let path1 = 
    let p1 = Path.smart_path 
    ~style:jLine
    [Right;Up;Right]
    (Point.pt (bp 0.,bp 0.)) 
    (Point.pt (bp 50.,bp 50.))
    in
    Command.draw p1
  \end{alltt}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\begin{center}
\includegraphics{path1.mps}
\end{center}
\end{minipage}

~\\
\begin{minipage}{0.5\linewidth}
  \begin{alltt}
    let path2 = 
    let p2 = Path.smart_path 
    [Right;Down;Left;Down;
      Right;Down;Left;Down;Right]
    ~style:jLine
    (Point.pt (bp 0.,bp 100.)) 
    (Point.pt (bp 100.,bp 0.))
    in
    Command.draw_arrow p2
  \end{alltt}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\begin{center}
\includegraphics[scale=0.8]{path2.mps}
\end{center}
\end{minipage}

~\\
\begin{minipage}{0.5\linewidth}
  \begin{alltt}
    let path3 = 
    let p3 = Path.smart_path 
    [Left;Down;Left;Down;Left] 
    (Point.pt (bp 0.,bp 0.)) 
    (Point.pt (bp (-50.),bp (-50.)))
    in
    Command.draw_arrow p3
  \end{alltt}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\begin{center}
\includegraphics{path3.mps}
\end{center}
\end{minipage}

~\\
\begin{minipage}{0.5\linewidth}
  \begin{alltt}
    let path4 = 
    let p4 = Path.smart_path 
    [Down;Right;Upn (bp 10.);
      Right;Downn (bp 10.);
      Right;Upn (bp 10.);
      Right;Downn (bp 10.);
      Right;Upn (bp 10.);
      Right;Down]
    (Point.pt (bp 0.,bp 100.)) 
    (Point.pt (bp 100.,bp 0.))
    in
    Command.draw p4
  \end{alltt}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\begin{center}
\includegraphics{path4.mps}
\end{center}
\end{minipage}


\subsection{Arbres}
Ce module permet la création d'arbres \mlpost\ de façon esthétique.
Il s'appuie sur l'ancien module Tree de \mlpost\ (qu'il a remplacé), ainsi que sur l'article d'un chercheur américain. \cite{tree}
~\\
Le module contient deux fonctions principales:
\begin{itemize}
\item node pour construire un noeud
  \begin{alltt}
    val node : 
    ?ls:Num.t -> ?cs:Num.t -> 
    ?arrow_style:arrow_style -> 
    ?edge_style:edge_style -> 
    ?stroke:Color.t -> ?pen:Pen.t ->
    Box.t -> t list -> t
  \end{alltt}
  La liste contient les éventuels sous arbres.~\\
\item leaf pour construire une feuille
  \begin{alltt}
    val leaf : Box.t -> t
  \end{alltt}
\end{itemize}

Quelques exemples d'arbres:

~\\

\begin{minipage}{0.5\linewidth}
  \begin{alltt}
    let tree1 =
    let node s = Tree.node ~edge_style:Curve 
    (Box.tex s) in
    let leaf s = Tree.leaf (Box.tex s) in
    Tree.draw (node "1" 
    [node "2" [leaf "4"; leaf "5"]; 
      node "3" [leaf "6"; leaf "7"]])
  \end{alltt}
\end{minipage}
\begin{minipage}{0.5\linewidth}
  \begin{center}
    \includegraphics[scale=1.75]{tree1.mps}
  \end{center}
\end{minipage}

~\\

\begin{minipage}{0.5\linewidth}
  \begin{alltt}
    let tree2 =
    let node s = 
    Tree.node ~arrow_style:Undirected 
    ~edge_style:HalfSquare (Box.tex s) in
    let leaf s = Tree.leaf (Box.tex s) in
    Tree.draw 
    (node "1" [
      node "2" [node "4" [leaf "8"]; leaf "5"]; 
      node "3" [node "6" [leaf "9"; node "10" 
          [leaf "12"; leaf "13"]];node "7" 
        [leaf "11"]]])
  \end{alltt}
\end{minipage}
\begin{minipage}{0.5\linewidth}
  \begin{center}
    \includegraphics[scale=1.75]{tree2.mps}
  \end{center}
\end{minipage}

~\\

\begin{minipage}{0.5\linewidth}
  \begin{alltt}
    let leaf s = Tree.leaf 
    (Box.set_stroke Color.black (Box.tex s))
    let node s l = Tree.node  
    ~arrow_style:Undirected 
    ~edge_style:Straight 
    ~ls:(bp 30.)
    (Box.set_stroke Color.black 
    (Box.tex s)) l
  \end{alltt}
\end{minipage}
\begin{minipage}{0.5\linewidth}
  \begin{center}
    \includegraphics[scale=1.4]{tree3.mps}
  \end{center}
\end{minipage}
\begin{alltt}
  let subtree = node "subroot" [leaf "son1"; leaf "son2"; leaf "son3"]
  let treebox = Box.rect (to_box subtree)
  let maintree = node "root" [subtree; leaf "son"; Tree.node treebox [subtree]]
  let tree3 = Tree.draw maintree 
\end{alltt}
\section{Interface graphique}
\gmlpost\ est une interface graphique pour \mlpost\ permettant d'éditer des figures à partir d'un fichier \textit{.ml}. 
\subsection{Motivations}
Le processus de création ou d'édition d'une figure peut être ennuyeux lorsque l'on essaie de regler certaines valeurs à tatons. Il faut avoir un editeur de texte lancé, éventuellement un terminal, et il faut recompiler à chaque fois et lancer le fichier postscript ou le pdf obtenu avec un viewer.

~\\Grâce à \gmlpost, il suffit de lancer le fichier, et l'interface va permettre à l'utilisateur, soit de modifier les valeurs elles-mêmes dans la partie gauche, soit de déplacer les points éditables sur le canvas situé sur la partie droite de la fenêtre.
~\\Ainsi les actions de l'utilisateur se limitent désormais à éditer des valeurs et rafraichir l'image, ce qui devient quasi-instantané.
\subsection{Structure}
\gmlpost\ n'a nécessité aucune modification de \mlpost, nous y avons seulement dû ajouter un module Edit par dessus le module Num.

L'interface de ce module comporte ces deux fonctions:
\begin{alltt}
  val num: string -> float -> Glexer.dimension -> Num.t

  val point: string -> 
  float -> Glexer.dimension -> 
  float -> Glexer.dimension -> Point.t
\end{alltt}

Lors de la compilation d'un fichier par \gmlpost, les Num et les Point éditables sont interprété par le fichier \textit{glexer.mll}. Puis le programme crée un fichier \textit{fig.edit} contenant des éléments définis par le type:
\begin{alltt}
  type elt = 
  | Num of string * value
  | Point of string * value * value
\end{alltt}
avec value le type:
\begin{alltt}
  type value = float * dimension
\end{alltt}
et dimension le type:
\begin{alltt}
  type dimension =
  Pt | Cm | Mm | Bp | Inch
\end{alltt}

\gmlpost\ peut enfin utiliser le fichier généré pour créer l'image de la figure \mlpost\ et afficher celle-ci ainsi que ses valeurs éditables, et ses points déplaçables sur le canvas.
~\\

Lors d'un rafraichissement, le programme va écraser le fichier \textit{fig.edit} avec les nouvelles valeurs, et compiler la nouvelle image fraichement obtenue.

~\\

Schéma de l'exécution au démarrage:
\begin{center}
\includegraphics{interface1.mps}
\end{center}

~\\

Schéma de l'exécution du rafraîchissement:
\begin{center}
\includegraphics{interface2.mps}
\end{center}

\subsection{Screenshots}
\section{Conclusion}

\begin{thebibliography}{99}
\bibitem{mlpost} \mlpost, une bibliothèque de dessin 
 scientifique pour Objective Caml.

\bibitem{tree}
Andrew Kennedy. 
\emph{Drawing Trees.}
Journal of Functional Programming, 
6(3): 527--534, Cambridge University Press, May 1996.
\end{thebibliography}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% mode: whizzytex
%%% mode: flyspell
%%% ispell-local-dictionary: "francais-latin1"
%%% End: 
