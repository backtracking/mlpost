\documentclass[a4paper,12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{fullpage,url,graphicx,alltt}

\newcommand{\mlpost}{\textsc{Mlpost}}
\newcommand{\gmlpost}{\textsc{GMlpost}}
\newcommand{\meta}{\textsc{Metapost}}

\begin{document}

\section{Introduction}

\subsection{Présentation de \mlpost}
\mlpost\ est une interface Objective Caml de \meta, permettant la création de figures. \cite{mlpost}

\subsubsection{Motivations}
Dans un cadre scientifique, il est très souvent nécessaire d'inclure des figures aux documents (cours, articles). Il existe bien sûr de nombreux éditeurs graphiques, mais la conception de figures complexes s'avère longue et nuit à l'homogénéité du tout. 
~\\Une façon très commune de rédiger ces documents est d'utiliser \LaTeX. \LaTeX\ permet l'importation d'images, voire la création, mais ceci reste compliqué, long, et les erreurs sont difficiles à interpréter. Il doit également être possible d'ajouter des éléments de \LaTeX\ à la figure, et de garder une homogénéité du document. 

~\\L'utilisation d'un langage comme OCaml, avec un typage fort et des erreur plus simples à déchiffrer s'imposait donc! De plus, OCaml bénéficie d'arguments optionnels, très pratiques dans la conception d'une librairie graphique.Enfin, la quantité de code tapé devient plus concise, rendant la conception de figures possible d'un simple appel de fonction.

~\\Enfin il est important de préciser qu'une figure \mlpost\ peut être utilisée comme la vue du résultat d'un calcul ou d'un algorithme OCaml. On pourra par exemple calculer un arbre couvrant d'un graphe, et le représenter sous forme d'arbre \mlpost\ dans le même programme.

\subsubsection{Structure de \mlpost}
\mlpost\ est constitué de nombreux modules open sources séparés en quatre catégories:
\begin{itemize}
\item les interfaces des types basiques de \meta\ (Command,Num,Point,Path,Picture...)
\item les composants graphique avancés (Box,Shapes,Arrow...) 
\item les extensions (Tree,Histogram,Diag,Plot...)
\item les modules de génération de \meta
\end{itemize}

Pour simplifier les choses, on peut dire qu'une figure est une somme de Command qui sera passée aux modules de génération de \meta.


\subsubsection{Exemples}
Un exemple facile d'utilisation de boîte avec \mlpost. On notera l'utilisation du symbole mathématique $\pi$ qui se fait aisément en conservant l'homogénéité du tout, ainsi que la concision du code pour générer la boîte. 
~\\

\begin{minipage}{0.7\linewidth}
  \begin{alltt}
    let simple_block =
    let b = Box.hblock ~pos:`Bot 
    [Box.tex "a"; Box.tex "A"; Box.tex "1"; Box.tex "$\\pi$"] 
    in
    Box.draw b
  \end{alltt}
\end{minipage}
\begin{minipage}{0.3\linewidth}
  \begin{center}
    \includegraphics[scale=2]{simple_block.mps}
  \end{center}
\end{minipage}


Un exemple légèrement plus compliqué dans lequel on utilise des arguments optionnels pour mieux personnaliser la figure.
~\\

\begin{minipage}{0.7\linewidth}
  \begin{alltt}
    let traffic =
    let two = Num.bp 2. in
    let b = 
    vbox ~fill:black ~padding:(Num.bp 3.) ~dx:two ~dy:two
    [ tex ~style:Circle ~fill:red "R";
      tex ~style:Circle ~fill:yellow "Y";
      tex ~style:Circle ~fill:green "G"; ]
    in
    draw b
  \end{alltt}
\end{minipage}
\begin{minipage}{0.3\linewidth}
  \begin{center}
    \includegraphics[scale=2]{traffic.mps}
  \end{center}
\end{minipage}

Un dernier exemple plus compliqué utilisant les module Path, Point et Pen pour dessiner un rubik's cube. Cette figure étant le résultat d'un calcul, on voit bien à quel point il serait facile de changer certains paramètres pour la modifier.
~\\

\begin{minipage}{0.7\linewidth}
  \begin{alltt}
    let alpha = atan 1.
    let beta = atan 1. /. 2. 
    let mag = 10.
    
    let proj x y z = 
    mag *. float (x - y) *. cos alpha, 
    mag *. (float (x + y) *. sin alpha *. sin beta +. float z *. cos beta)
    
    let pen = Pen.scale (bp 2.5) Pen.default
  
    let square color p i j =
    let pt i j = let x,y = p i j in 
    Point.pt (bp x, bp y) in
    let points = [pt i j; pt (i+1) j; 
      pt (i+1) (j+1); pt i (j+1)] in
    let path = pathp ~style:jLine 
    ~cycle:jLine points in
    seq [fill ~color path; Command.draw ~pen path]
    
    let right = square Color.orange (fun i j -> proj i 0 j)
    let up = square Color.yellow (fun i j -> proj i j 3)
    let left = square Color.green (fun i j -> proj 0 (3 - i) j)
    
    let rubik = 
    seq [iter 0 2 (fun i -> iter 0 2 (right i));
      iter 0 2 (fun i -> iter 0 2 (up i));
      iter 0 2 (fun i -> iter 0 2 (left i));]
  \end{alltt}
\end{minipage}
\begin{minipage}{0.3\linewidth}
  \begin{center}
    \includegraphics[scale=3]{rubik.mps}
  \end{center}
\end{minipage}

\subsection{Notre TER}
Le sujet du stage était à l'origine \textit{Implémentation d'une bibliothèque de diagrammes pour \mlpost}.Il s'agissait de réaliser une extension de \mlpost, sans bien sûr avoir à modifier ce qui était déjà présent. Nous avons donc dû d'abord maîtriser très vite l'API.
Pour ce stage, il fallait bien sûr que notre API soit claire, dans les choix de types, de noms de fonctions et d'arguments (surtout optionnels), et qu'elle soit accompagnée d'une documentation (conçue avec \textsc{OCamldoc}).

Dans la deuxième partie du stage, notre encadrant nous a proposé de modifier le module Tree et d'implémenter une interface graphique pour \mlpost.

\subsubsection{Modules au dessus de \mlpost}
Nous avons travaillé sur cinq modules. 
Sur ces cinq modules, nous en avons créé trois (Histogram,Radar,Legend), enrichi un (Path), et modifié un autre (Tree).
Nos trois modules sont des modules \og haut niveau\fg\ qui n'ont nécessité aucune modification du noyau de \mlpost. 
\subsubsection{Interface Graphique}
\gmlpost\ est une interface graphique de \mlpost\ permettant l'édition de figure \mlpost\ avec un gain de temps de praticité. Sa conception nous a permis de devenir familier avec \textsc{lablgtk2} (et donc \textsc{gkt2} par extension) et d'utiliser à nouveau l'outil \textsc{OCamllex}.

\section{Modules \mlpost}

\subsection{Histogram}
Il existe trois types d'histogramme:

\subsubsection{Simple:}
Un histogramme classique construit à partir d'une liste de nombres
flottants.

~\\

\begin{minipage}{0.5\linewidth}
  \begin{alltt}
    let hist = Hist.simple [3.;1.;6.]
  \end{alltt}
\end{minipage}
\begin{minipage}{0.5\linewidth}
  \begin{center}
    \includegraphics[scale=0.5]{hist1.mps}
  \end{center}
\end{minipage}

\subsubsection{Comparatif :} 
Un histogramme comparatif construit à partir d'une liste. Cette liste
contient N listes de nombres flottants, chacune étant un histogramme.

~\\

\begin{minipage}{0.5\linewidth}
  \begin{alltt}
    let hist = Hist.compare
    [[1.;5.;6.;5.;3.];
      [1.;2.;3.;6.;-1.]]
  \end{alltt}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\begin{center}
\includegraphics[scale=0.5]{hist2.mps}
\end{center}
\end{minipage}

\subsubsection{Cumulatif :} 
Un histogramme cumulatif.

~\\

\begin{minipage}{0.5\linewidth}
  \begin{alltt}
    let hist = Hist.stack 
    ~fill:[lightred;lightblue
      ;lightyellow;lightgreen]
    [[4.;5.;5.;]; [8.;3.;1.]; [2.;8.;1.;4.]]
  \end{alltt}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\begin{center}
\includegraphics[scale=0.5]{hist3.mps}
\end{center}
\end{minipage}

\subsubsection{Pour aller plus loin:}
Il est possible de faire des histogrammes bien plus complexes, mais toujours de façon très simple.

~\\

\begin{minipage}{0.5\linewidth}
  \begin{alltt}
    let hist =
    let pics =
    List.map Picture.tex ["2000";"2001";
      "2002";"2003";"2004";"2005"]
    in
    Hist.simple 
    ~histlabel:(`Top, Hist.User pics)
    [4.5;5.0;6.2;8.;7.2;6.1]
  \end{alltt}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\begin{center}
\includegraphics[scale=0.5]{hist4.mps}
\end{center}
\end{minipage}

~\\

\begin{minipage}{0.5\linewidth}
  \begin{alltt}
    let hist = Hist.stack
    ~perspective:true ~padding:(bp 25.)
    ~fill:[lightred;lightblue;
      lightyellow;lightgreen]
    ~histlabel:(`Center, Hist.Values)
    [[4.;5.;5.;]; [8.;3.;1.]; [2.;8.;1.;4.]]
  \end{alltt}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\begin{center}
\includegraphics[scale=0.5]{hist5.mps}
\end{center}
\end{minipage}

\subsection{Radar}
Ce module permet la création de diagrammes radar.
Nous donnons la possibilité d'en créer deux sortes.
Lorsqu'un radar est créé, l'objet \mlpost\ renvoyé est une Picture.
Nous en verrons l'utilité plus tard.

\subsubsection{Cumulatif:}
Le diagramme radar classique. Toutes les données sont regroupées sur la même figure, de façon à les comparer instantanément. 

~\\

\begin{minipage}{0.5\linewidth}
  \begin{alltt}
    let radar =
    let pic =
    Radar.stack
    ~pen:(Pen.scale (bp 3.) Pen.circle)
    ~color:[blue;red;green]
    ~label:["weight";"acceleration";
      "speed";"maniability";"stickiness"]
    [[3.;4.;5.;6.;4.];
      [6.;5.;2.;1.;1.];
      [1.;7.;2.;4.;5.]]
    in
    Command.draw_pic pic
  \end{alltt}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\begin{center}
\includegraphics[scale=0.8]{radar1.mps}
\end{center}
\end{minipage}

\subsubsection{Comparatif}
Contrairement au diagramme précédent, celui ci ne fabrique pas qu'une seule Picture, mais autant qu'il existe d'objets à comparer. Cela permet donc un plus grand choix dans la mise en page.

~\\

\begin{minipage}{0.5\linewidth}
  \begin{alltt}
    let radar =
    let pics =
    Radar.compare
    ~pen:(Pen.scale (bp 1.5) Pen.circle)
    ~color:[lightblue;lightred;lightgreen] 
    ~fill:true
    [[3.;4.;5.;6.;4.];
      [6.;5.;2.;1.;1.];
      [1.;7.;2.;4.;5.]]
    in
    Box.draw (Box.vbox ~padding:(bp 10.) 
    (List.map (Box.pic ~stroke:None) pics))

  \end{alltt}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\begin{center}
\includegraphics[scale=0.5]{radar2.mps}
\end{center}
\end{minipage}

\subsection{Path}
Dans \mlpost, le module Path permet à l'utilisateur de tracer toutes sortes de lignes, qu'elles soient droites ou des courbes de Bézier, et ce par le biais de nombreuses fonctions.
Nous n'avons rien modifié de ce qui était déjà en place. Nous avons seulement ajouter une nouvelle manière de tracer un Path, appelée \textit{smart\_path}. 

~\\Cette fonction prend en paramètre deux points: le point de départ du Path, et le point d'arrivée. 
\begin{alltt}
  val smart_path : ?style:joint -> orientation list -> Point.t -> Point.t -> t
\end{alltt}
~\\La particularité de \textit{smart\_path} est que la fonction prend un troisième paramètre, qui est une liste d'orientations.
~\\Le type orientation se définit comme ceci:
\begin{alltt}
  type orientation =
  Up | Down | Left | Right |
  Upn of Num.t | Downn of Num.t | Leftn of Num.t | Rightn of Num.t
\end{alltt}
Ceci permet à l'utilisateur de choisir la façon dont il veut relier les deux points. Dans la mesure du possible, \mlpost\ créera ce path, ou retournera une erreur. 

~\\exemples d'utilisations de \textit{smart\_path}:

~\\
\begin{minipage}{0.5\linewidth}
  \begin{alltt}
    let path1 = 
    let p1 = Path.smart_path 
    ~style:jLine
    [Right;Up;Right]
    (Point.pt (bp 0.,bp 0.)) 
    (Point.pt (bp 50.,bp 50.))
    in
    Command.draw p1
  \end{alltt}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\begin{center}
\includegraphics{path1.mps}
\end{center}
\end{minipage}

~\\
\begin{minipage}{0.5\linewidth}
  \begin{alltt}
    let path2 = 
    let p2 = Path.smart_path 
    [Right;Down;Left;Down;
      Right;Down;Left;Down;Right]
    ~style:jLine
    (Point.pt (bp 0.,bp 100.)) 
    (Point.pt (bp 100.,bp 0.))
    in
    Command.draw_arrow p2
  \end{alltt}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\begin{center}
\includegraphics[scale=0.8]{path2.mps}
\end{center}
\end{minipage}

~\\
\begin{minipage}{0.5\linewidth}
  \begin{alltt}
    let path3 = 
    let p3 = Path.smart_path 
    [Left;Down;Left;Down;Left] 
    (Point.pt (bp 0.,bp 0.)) 
    (Point.pt (bp (-50.),bp (-50.)))
    in
    Command.draw_arrow p3
  \end{alltt}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\begin{center}
\includegraphics{path3.mps}
\end{center}
\end{minipage}

~\\
\begin{minipage}{0.5\linewidth}
  \begin{alltt}
    let path4 = 
    let p4 = Path.smart_path 
    [Down;Right;Upn (bp 10.);
      Right;Downn (bp 10.);
      Right;Upn (bp 10.);
      Right;Downn (bp 10.);
      Right;Upn (bp 10.);
      Right;Down]
    (Point.pt (bp 0.,bp 100.)) 
    (Point.pt (bp 100.,bp 0.))
    in
    Command.draw p4
  \end{alltt}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\begin{center}
\includegraphics{path4.mps}
\end{center}
\end{minipage}


\subsection{Tree}
Ce module permet la création d'arbres \mlpost\ de façon esthétique.
Il s'appuie sur l'ancien module Tree de \mlpost\ (qu'il a remplacé), ainsi que sur l'article d'un chercheur américain. \cite{tree}
~\\
Le module contient deux fonctions principales:
\begin{itemize}
\item node pour construire un noeud
  \begin{alltt}
    val node : 
    ?ls:Num.t -> ?cs:Num.t -> 
    ?arrow_style:arrow_style -> 
    ?edge_style:edge_style -> 
    ?stroke:Color.t -> ?pen:Pen.t ->
    Box.t -> t list -> t
  \end{alltt}
  La liste contient les éventuels sous arbres.~\\
\item leaf pour construire une feuille
  \begin{alltt}
    val leaf : Box.t -> t
  \end{alltt}
\end{itemize}

Quelques exemples d'arbres:

~\\

\begin{minipage}{0.5\linewidth}
  \begin{alltt}
    let tree1 =
    let node s = Tree.node ~edge_style:Curve 
    (Box.tex s) in
    let leaf s = Tree.leaf (Box.tex s) in
    Tree.draw (node "1" 
    [node "2" [leaf "4"; leaf "5"]; 
      node "3" [leaf "6"; leaf "7"]])
  \end{alltt}
\end{minipage}
\begin{minipage}{0.5\linewidth}
  \begin{center}
    \includegraphics[scale=1.75]{tree1.mps}
  \end{center}
\end{minipage}

~\\

\begin{minipage}{0.5\linewidth}
  \begin{alltt}
    let tree2 =
    let node s = 
    Tree.node ~arrow_style:Undirected 
    ~edge_style:HalfSquare (Box.tex s) in
    let leaf s = Tree.leaf (Box.tex s) in
    Tree.draw 
    (node "1" [
      node "2" [node "4" [leaf "8"]; leaf "5"]; 
      node "3" [node "6" [leaf "9"; node "10" 
          [leaf "12"; leaf "13"]];node "7" 
        [leaf "11"]]])
  \end{alltt}
\end{minipage}
\begin{minipage}{0.5\linewidth}
  \begin{center}
    \includegraphics[scale=1.75]{tree2.mps}
  \end{center}
\end{minipage}

~\\

\begin{minipage}{0.5\linewidth}
  \begin{alltt}
    let leaf s = Tree.leaf 
    (Box.set_stroke Color.black (Box.tex s))
    let node s l = Tree.node  
    ~arrow_style:Undirected 
    ~edge_style:Straight 
    ~ls:(bp 30.)
    (Box.set_stroke Color.black 
    (Box.tex s)) l
  \end{alltt}
\end{minipage}
\begin{minipage}{0.5\linewidth}
  \begin{center}
    \includegraphics[scale=1.1]{tree3.mps}
  \end{center}
\end{minipage}

~\\

\begin{alltt}
  let subtree = node "subroot" [leaf "son1"; leaf "son2"; leaf "son3"]
  let treebox = Box.rect (to_box subtree)
  let maintree = node "root" [subtree; leaf "son"; Tree.node treebox [subtree]]
  let tree3 = Tree.draw maintree 
\end{alltt}

\subsection{Legend}
Un petit module, très pratique, servant à représenter la légende d'une figure \mlpost\ quelconque.

La signature du module est définie comme ceci:
\begin{alltt}
  val legend : 
  ?ensstroke:Color.t ->
  ?colstroke:Color.t ->
  ?fill:Color.t ->
  (Color.t * string) list -> Picture.t
\end{alltt}

Cette fonction prend en argument une liste de couples couleur/chaine, et renvoie une Picture. Celle ci peut ainsi être dessinée n'importe où sur ou à côté de la figure à laquelle elle se rapporte.

~\\

\begin{minipage}{0.5\linewidth}
  \begin{alltt}
    let legend1 = 
    let l = Legend.legend
    [(Color.lightgreen,"2009");
      (Color.lightyellow,"2010");
      (Color.lightred,"2011")]
    in Command.draw_pic l
  \end{alltt}
\end{minipage}
\begin{minipage}{0.5\linewidth}
  \begin{center}
    \includegraphics[scale=1.5]{legend1.mps}
  \end{center}
\end{minipage}


\section{Interface graphique}
\gmlpost\ est une interface graphique pour \mlpost\ permettant d'éditer des figures à partir d'un fichier \textit{.ml}. 
\subsection{Motivations}
Le processus de création ou d'édition d'une figure peut être ennuyeux lorsque l'on essaie de regler certaines valeurs à tatons. Il faut avoir un editeur de texte lancé, éventuellement un terminal, et il faut recompiler à chaque fois et lancer le fichier postscript ou le pdf obtenu avec un viewer.

~\\Grâce à \gmlpost, il suffit de lancer le fichier, et l'interface va permettre à l'utilisateur, soit de modifier les valeurs elles-mêmes dans la partie gauche, soit de déplacer les points éditables sur le canvas situé sur la partie droite de la fenêtre.
~\\Ainsi les actions de l'utilisateur se limitent désormais à éditer des valeurs et rafraichir l'image, ce qui devient quasi-instantané.
\subsection{Structure}
\gmlpost\ n'a nécessité aucune modification de \mlpost, nous y avons seulement dû ajouter un module Edit par dessus le module Num.

L'interface de ce module comporte ces deux fonctions:
\begin{alltt}
  val num: string -> float -> Glexer.dimension -> Num.t

  val point: string -> 
  float -> Glexer.dimension -> 
  float -> Glexer.dimension -> Point.t
\end{alltt}

Lors de la compilation d'un fichier par \gmlpost, les Num et les Point éditables sont interprété par le fichier \textit{glexer.mll}. Puis le programme crée un fichier \textit{fig.edit} contenant des éléments définis par le type:
\begin{alltt}
  type elt = 
  | Num of string * value
  | Point of string * value * value
\end{alltt}
avec value le type:
\begin{alltt}
  type value = float * dimension
\end{alltt}
et dimension le type:
\begin{alltt}
  type dimension =
  Pt | Cm | Mm | Bp | Inch
\end{alltt}

\gmlpost\ peut enfin utiliser le fichier généré pour créer l'image de la figure \mlpost\ et afficher celle-ci ainsi que ses valeurs éditables, et ses points déplaçables sur le canvas.
~\\

Lors d'un rafraichissement, le programme va écraser le fichier \textit{fig.edit} avec les nouvelles valeurs, et compiler la nouvelle image fraichement obtenue.

~\\

Schéma de l'exécution au démarrage:
\begin{center}
\includegraphics{interface1.mps}
\end{center}

~\\

Schéma de l'exécution du rafraîchissement:
\begin{center}
\includegraphics{interface2.mps}
\end{center}

\subsection{Screenshots}
\section{Conclusion}

\begin{thebibliography}{99}
\bibitem{mlpost} \mlpost, une bibliothèque OCaml développée au sein du projet Proval de l’INRIA Saclay – Île-de-France, permettant la réalisation de dessins scientifiques destinés à être inclus dans des documents \LaTeX.

Auteurs:
\begin{itemize}
    \item Romain Bardou
    \item Johannes Kanig
    \item Stéphane Lescuyer
    \item Jean-Christophe Filliâtre 
\end{itemize}

\bibitem{tree}
Andrew Kennedy. 
\emph{Drawing Trees.}
Journal of Functional Programming, 
6(3): 527--534, Cambridge University Press, May 1996.
\end{thebibliography}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% mode: whizzytex
%%% mode: flyspell
%%% ispell-local-dictionary: "francais-latin1"
%%% End: 
