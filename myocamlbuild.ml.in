open Ocamlbuild_plugin
open Command

let cairopossible = "@CAIRO@" = "yes"
let tagcairo = ref false

let packages_cairo = ["cairo","@CAIROLIB@","cairo";
                      "bitstring","@BITSTRINGLIB@","bitstring"]

let packages = ["lablgtk2","@LABLGTK2LIB@","lablgtk";
                "lablgnomecanvas","@LABLGTK2LIB@","lablgnomecanvas"]

let syntaxes = ["bitstring","@BITSTRINGLIB@",
                "camlp4o -I @BITSTRINGLIB@ bitstring.cma bitstring_persistent.cma pa_bitstring.cmo"]

let img_doc_prod = ["circle";"rect";"ellipse";"round_rect";
                    "patatoid";"tex";"ctr";"north";"south";
                    "west";"east";"north_west";"south_west";
                    "north_east";"south_east";"width";"height";
	            "shift";"center"]

(*Filename.generic_quote*)
let generic_quote whatquote quotequote s =
  let l = String.length s in
  let b = Buffer.create (l + 20) in
  for i = 0 to l - 1 do
    if s.[i] = whatquote
    then Buffer.add_string b quotequote
    else Buffer.add_char b  s.[i]
  done;
  Buffer.contents b


let _ = dispatch begin function
  | Before_options -> 
      Options.include_dirs := ["backend";"gui"];
      Options.ocamldoc := S[A"ocamldoc"]
  | Before_rules ->
      tagcairo := Ocamlbuild_pack.Configuration.has_tag "cairo_yes";
      if !tagcairo && not cairopossible then failwith ("configure don't find the library for the cairo backend, I can't compile");


       let yesnofile_rule file yesno ext = rule (file^" generation for "^yesno) ~deps:[file^yesno^ext] ~prod:(file^ext)
         (fun _ _ -> cp (file^yesno^ext) (file^ext)) in
       if !tagcairo
       then (yesnofile_rule "cairost" "_yes" ".ml";
             yesnofile_rule "cairost_sig" "_yes" ".ml";
             yesnofile_rule "mlpost" "_yes" ".mlpack";
            ) (*temporaire*)
       else (yesnofile_rule "cairost" "_no" ".ml";
             yesnofile_rule "cairost_sig" "_no" ".ml";
             yesnofile_rule "mlpost" "_no" ".mlpack";
            );

         (**doc *)
         rule "generation of the documentation" ~prod:"doc/index.html" 
           ~deps:["mlpost.docdir/index.html";"img/stamp"]
           (fun _ _ -> Cmd(Sh "rm -rf doc && cp -r mlpost.docdir doc && cp -r img doc"));

         flag ["ocaml"; "compile"; "use_ocamldoc"] & S[A"-I"; A "+ocamldoc"];
         dep ["ocaml";"doc"] ["customdoc/img.cmo"];
         flag ["ocaml";"doc"] & S[A"-hide" ; A "Mlpost"; A"-g"; A "customdoc/img.cmo"];

           rule "generation of the images for the documentation" 
             ~prod:"img/image.png"
             ~stamp:"img/stamp"
             ~deps:(List.map (fun x -> "img/"^x^".png") img_doc_prod)
             (fun _ _ -> Nop);

           

       (** For img *)
       rule "produce image in img from img_doc.ml"
         ~prods: (List.map (fun x -> "img/"^x^".1") img_doc_prod)
         ~dep: "customdoc/img_doc.byte"
         begin fun env _ ->
           Cmd(Sh "mkdir -p img/ && cd img/ && ../customdoc/img_doc.byte >> /dev/null && cd ..")
         end;
           

       (** conversion of images *)
       rule ".1 -> .dvi"
         ~prod: "%.dvi"
         ~deps: ["%.1";"customdoc/all.template"]
         begin fun env _ ->
           let base = env "%" in
           let dirname = Pathname.dirname base in
           let basename = Pathname.basename base in
           let sed =
             Sh(Printf.sprintf "sed -e 's/all/%s/' customdoc/all.template > %s.tex"
                  basename base)
           in
           let latex = S[
             A "cd" ; P dirname; Sh " && ";
             A "latex"; A "-interaction"; A "nonstopmode";
             A "-file-line-error"; A "-halt-on-error";
             A basename;
             Sh "> /dev/null"; (* DELETE THIS IF YOU WANT TO DEBUG *)
           ] in
           Seq[Cmd sed; Cmd latex]
         end;
       
       rule ".dvi -> .ps"
         ~prod: "%.ps"
         ~dep: "%.dvi"
         begin fun env _ ->
           let base = env "%.dvi" in
           let dirname = Pathname.dirname base in
           let basename = Pathname.basename base in
           Cmd(S[A "cd" ; P dirname; Sh " && ";A "dvips"; A "-q"; A "-E"; A basename; A "-o"])
         end;
       
      rule ".ps -> png"
        ~prod: "%.png"
        ~dep: "%.ps"
        begin fun env _ ->
          Cmd(S[A "convert"; A(env "%.ps"); A(env "%.png")])
        end;

      (*rule ".1 -> png"
        ~prod: "%.png"
        ~dep: "%.1"
        begin fun env _ ->
          Cmd(S[A "convert"; A(env "%.1"); A(env "%.png")])
        end;*)


  | After_rules ->

      if !tagcairo then
        ocaml_lib ~extern:true ~tag_name:("use_cairo_bigarray") "bigarray";

       List.iter begin function pkg,dir,file ->
         ocaml_lib ~extern:true ~tag_name:("pkg_"^pkg) ~dir file;
	 flag ["ocaml"; "pack";  "pkg_"^pkg] & S[A"-I"; P dir];
       end (if !tagcairo then packages_cairo@packages else packages);


       (* Like -package but for extensions syntax. Morover -syntax is useless
       	* when linking. *)
       List.iter begin function syntax,lib,pp ->
         flag ["ocaml"; "compile";  "syntax_"^syntax] & S[A"-pp"; A pp];
         flag ["ocaml"; "ocamldep"; "syntax_"^syntax] & S[A"-pp"; A pp];
         flag ["ocaml"; "doc";      "syntax_"^syntax] & S[A"-pp"; A pp];
       end syntaxes;
      

   | _ -> ()
end
